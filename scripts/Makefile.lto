#
# Support for gcc link time optimization
#

#
# -fuse-linker-plugin is needed to handle .a files
#

DISABLE_LTO :=
LTO_CFLAGS :=

export DISABLE_LTO
export LTO_CFLAGS

ifdef CONFIG_LTO
# XXX check linker version
ifeq ($(call cc-ifversion, -ge, 0407,y),y)
ifneq ($(call cc-option,${LTO_CFLAGS},n),n)
	LTO_CFLAGS := -fuse-linker-plugin -flto=16 -fno-toplevel-reorder -fno-fat-lto-objects
	DISABLE_LTO := -fno-lto

	LTO_FINAL_CFLAGS += ${LTO_CFLAGS} -fwhole-program 
ifndef CONFIG_LTO_FASTER_BUT_BROKEN
	LTO_FINAL_CFLAGS += -flto-partition=none
endif

ifdef CONFIG_LTO_DEBUG
	LTO_FINAL_CFLAGS += -dH #-fdump-ipa-cgraph -fdump-ipa-inline-details -Wl,-plugin-save-temps -save-temps   -dH
	LTO_CFLAGS += 
endif

	# need to explicitely enable the optimizer again on the link
	# stage
ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
	LTO_FINAL_CFLAGS   += -Os
else
	LTO_FINAL_CFLAGS   += -O2
endif

	LTO_FINAL_CFLAGS += $(filter -m32,${KBUILD_CFLAGS})
	LTO_FINAL_CFLAGS += $(filter -m64,${KBUILD_CFLAGS})

	KBUILD_CFLAGS += ${LTO_CFLAGS}

	#
	# Don't pass all flags to the optimization stage
	# We assume the compiler remembers those in the object files.
	# Currently gcc is a little dumb in this and uses the flags
	# from the first file, which implies that setting special
	# flags on files does not work.
	LDFINAL := ${CONFIG_SHELL} ${srctree}/scripts/gcc-ld \
                  ${LTO_FINAL_CFLAGS}

else
        X += $(warning "WARNING: Compiler/Linker does not support LTO/WHOPR with linker plugin. CONFIG_LTO disabled."))
endif
else
	X += $(warning "WARNING: GCC too old for LTO/WHOPR. CONFIG_LTO disabled")
endif
endif
